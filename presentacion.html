<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Coloreo de Grafos - Presentación</title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.6.1/dist/reveal.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.6.1/dist/theme/black.css">

    <style>
        .reveal .slides section {
            text-align: left;
        }
        .reveal h1, .reveal h2, .reveal h3 {
            color: #fff;
        }
        .reveal p, .reveal li {
            color: #e0e0e0;
        }
        .highlight {
            background-color: #007bff;
            color: #fff;
            padding: 5px;
            border-radius: 3px;
        }
        .example {
            background-color: #333;
            padding: 10px;
            margin: 10px 0;
            border-left: 5px solid #007bff;
        }
        /* Evitar parpadeo del código: ocultar hasta que se renderice */
        .reveal .slides .mermaid,
        .reveal .slides .dot { visibility: hidden; }
        .reveal .slides .mermaid[data-processed="true"],
        .reveal .slides .dot[data-processed="true"] { visibility: visible; }
    </style>
</head>
<body>
    <div class="reveal">
        <div class="slides">

            <!-- Diapositiva de Título -->
            <section>
                <h1>Coloreo de Grafos</h1>
                <p>Asignar colores a puntos conectados sin que compartan el mismo color</p>
                <p>El objetivo: usar la menor cantidad de colores posible.</p>
            </section>

            <!-- Aplicaciones Prácticas -->
            <section>
                <h2>Aplicaciones Prácticas</h2>
                <p>Ejemplos de aplicaciones:</p>
                <ul>
                    <li><strong>Horarios escolares:</strong> Asignar clases sin superposiciones</li>
                    <li><strong>Redes de radio/TV:</strong> Evitar interferencias entre canales</li>
                    <li><strong>Mapas geográficos:</strong> Colorear regiones adyacentes</li>
                    <li><strong>Planificación de recursos:</strong> Distribuir tareas en equipos</li>
                </ul>
            </section>


            <!-- ¿Por Qué es Difícil? -->
            <section>
                <h2>¿Por Qué es Difícil?</h2>
                <p>Con 1-2 colores, es fácil incluso para grafos grandes.</p>
                <p>Pero con 3 o más colores, se vuelve NP-completo – ¡puede tomar años encontrar la solución óptima, incluso en grafos pequeños!</p>
            </section>

            <!-- Analogías -->
            <section>
                <h2>Analogías para Entender</h2>
                <div class="example">
                    <strong>Analogía 1:</strong> Como colorear un mapa donde países vecinos no tengan el mismo color – ¡el clásico problema de mapas!
                </div>
                <div class="example">
                    <strong>Analogía 2:</strong> Organizar una fiesta donde amigos no se sienten juntos si no se llevan bien.
                </div>
            </section>

            <!-- Casos Fáciles -->
            <section>
                <h2>Casos Fáciles de Resolver</h2>
            </section>

            <section>
                <h3>Grafos Bipartitos</h3>
                <p>Se dividen en dos grupos sin conexiones internas. Solo necesitan 2 colores.</p>
                <div class="example">
                    <strong>Ejemplo:</strong> Estudiantes y cursos – estudiantes conectados a cursos que toman.
                </div>
                <div class="mermaid">
                    graph LR;
                    S1[Estudiante 1] --> C1[Curso A];
                    S1 --> C2[Curso B];
                    S2[Estudiante 2] --> C1;
                    S2 --> C2;
                    S2 --> C3[Curso C];
                </div>
            </section>

            <section>
                <h3>Grafos Planares</h3>
                <p>Como mapas en papel plano. Máximo 4 colores bastan.</p>
                <div class="example">
                    <strong>Ejemplo:</strong> Colorear un mapa de países.
                </div>
                <div class="mermaid">
                    graph TD;
                    Brasil --- Peru
                    Brasil --- Paraguay
                    Brasil --- Uruguay
                    
                    Chile --- Peru[Perú]
                    Chile --- Bolivia

                    Bolivia --- Peru
                    Bolivia --- Brasil
                    Bolivia --- Paraguay

                    Argentina[Argentina] --- Chile[Chile]
                    Argentina --- Bolivia[Bolivia]
                    Argentina --- Paraguay[Paraguay]
                    Argentina --- Brasil[Brasil]
                    Argentina --- Uruguay[Uruguay]                    
                    
                    Peru --- Brasil
                </div>
            </section>

            <!-- Algoritmos Básicos -->
            <section>
                <h2>Algoritmos Básicos</h2>
            </section>

            <section>
                <h3>Enfoque Codicioso</h3>
                <p>Asigna colores uno por uno, eligiendo el primero disponible.</p>
                <p><strong>Ventaja:</strong> Muy rápido, pero no siempre óptimo.</p>
                <div class="example">
                    <strong>Ejemplo:</strong> Llenar asientos en un teatro sin plan.
                </div>
            </section>

            <!-- Algoritmos Avanzados -->
            <section>
                <h2>Algoritmos Más Inteligentes</h2>
                <ul>
                    <li><strong>Welsh-Powell:</strong> Empieza por los puntos más conectados</li>
                    <li><strong>DSATUR:</strong> Elige dinámicamente el punto más "urgente"</li>
                    <li><strong>Backtracking:</strong> Prueba todas las opciones hasta encontrar la mejor</li>
                </ul>
                <p>Balancean velocidad y calidad para problemas grandes.</p>
            </section>

            <!-- Variantes del Problema -->
            <section>
                <h2>Variantes del Problema</h2>
                <ul>
                    <li><strong>Coloreo de Aristas:</strong> Colorear conexiones en lugar de puntos</li>
                    <li><strong>Coloreo Equitativo:</strong> Distribuir colores de forma justa</li>
                    <li><strong>Coloreo Dinámico:</strong> Adaptarse a cambios en el grafo</li>
                </ul>
                <p>Cada variante resuelve necesidades específicas.</p>
            </section>



            <!-- Conclusión -->
            <!-- Métricas y Rendimiento -->
            <section>
                <h2>Mediciones de Algoritmo Fuerza Bruta</h2>
                <p>Tiempo vs n en grafo completo; escala logarítmica.</p>
            </section>

            <section>
                <h3>Mediciones reales hasta n = 10</h3>
                <figure class="r-stretch">
                    <img src="graficos/bruteforce-time-vs-n.png" alt="Tiempo vs n (fuerza bruta) hasta n=10 - mediciones reales">
                    <figcaption>Grafo completo, resultados de medición; escala logarítmica.</figcaption>
                </figure>
            </section>

            <section>
                <h3>Proyección hasta n = 40 (regresión lineal)</h3>
                <figure class="r-stretch">
                    <img src="graficos/bruteforce-time-vs-n-up-to-40.png" alt="Tiempo vs n (fuerza bruta) hasta n=40 - proyección por regresión lineal">
                    <figcaption>Estimación basada en regresión lineal de mediciones; escala logarítmica.</figcaption>
                </figure>
            </section>

            <!-- Escala temporal intermedia -->
            <section>
                <h2>Escala del Tiempo (1)</h2>
                <p><strong>10<sup>4</sup> ms</strong> = 10 segundos.</p>
                <div class="example">Parpadear, leer una notificación, cargar una página web.</div>
            </section>

            <section>
                <h2>Escala del Tiempo (2)</h2>
                <p><strong>10<sup>8</sup> ms</strong> = 100&nbsp;000 s ≈ 27.8 h ≈ 1.2 días.</p>
                <div class="example">Aproximadamente un día y medio.</div>
            </section>

            <section>
                <h2>Escala del Tiempo (3)</h2>
                <p><strong>10<sup>12</sup> ms</strong> = 10<sup>9</sup> s ≈ 31.7 años.</p>
                <div class="example">Unas tres décadas.</div>
            </section>

            <section>
                <h2>Escala del Tiempo (4)</h2>
                <p><strong>10<sup>16</sup> ms</strong> = 10<sup>13</sup> s ≈ 3.17 × 10<sup>5</sup> años (≈ 317 mil años).</p>
                <div class="example">Más de 300 mil años.</div>
            </section>

            <!-- Explicación didáctica del tiempo 10^24 ms -->
            <section>
                <h2>¿Cuánto es <span class="highlight">10<sup>24</sup> ms</span>?</h2>
                <p>Ese punto (n = 36) en la gráfica equivale a:</p>
                <ul>
                    <li><strong>10<sup>24</sup> milisegundos</strong></li>
                    <li>= <strong>10<sup>21</sup> segundos</strong></li>
                    <li>= <strong>1.67 × 10<sup>19</sup> minutos</strong></li>
                    <li>= <strong>2.78 × 10<sup>17</sup> horas</strong></li>
                    <li>= <strong>1.16 × 10<sup>16</sup> días</strong></li>
                    <li>= <strong>≈ 3.17 × 10<sup>13</sup> años</strong> (≈ 31.7 billones; billón = 10<sup>12</sup>)</li>
                </ul>
                <div class="example">
                    <strong>Para dimensionar:</strong>
                    <ul>
                        <li>La <em>edad del universo</em> es ≈ <strong>13.8 mil millones</strong> de años (1.38 × 10<sup>10</sup>).</li>
                        <li>10<sup>24</sup> ms es ≈ <strong>2,300 veces</strong> esa edad.</li>
                    </ul>
                    Conclusión: la fuerza bruta no escala; tamaños moderados se vuelven imposibles en la práctica.
                </div>
            </section>

            <!-- Conclusión -->
            <!-- Visualización de Tipos de Grafos -->
            <section>
                <h2>Visualización de Tipos de Grafos</h2>
                <p>Ejemplos pequeños para cada familia definida en el código.</p>
            </section>

            <section>
                <h3>Ciclo (Cycle)</h3>
                <p>Todos los nodos forman un anillo; cada uno conecta con dos vecinos.</p>
                <div class="mermaid">
                    graph LR;
                    A((v0)) --- B((v1)) --- C((v2)) --- D((v3)) --- E((v4)) --- A
                </div>
            </section>

            <!-- Alternativa DOT: Ciclo (circular exacto) -->
            <section>
                <h3>Ciclo (DOT)</h3>
                <p>Distribución circular forzada con layout=circo.</p>
                <div class="dot">
digraph G {
  layout=circo;
  node [shape=circle style=filled fillcolor="#2b2b2b" fontcolor="#ffffff"];
  A [label="v0"]; B [label="v1"]; C [label="v2"]; D [label="v3"]; E [label="v4"];
  A -- B; B -- C; C -- D; D -- E; E -- A;
}
                </div>
            </section>

            <section>
                <h3>Completo (Clique)</h3>
                <p>Todos los nodos conectados entre sí (máximo número de aristas).</p>
                <div class="mermaid">
                    graph LR;
                    K1((k0)) --- K2((k1))
                    K1 --- K3((k2))
                    K1 --- K4((k3))
                    K2 --- K3
                    K2 --- K4
                    K3 --- K4
                </div>
            </section>

            <!-- Alternativa DOT: Completo (clique) -->
            <section>
                <h3>Completo (DOT)</h3>
                <p>Todos con todos; layout=neato para distribución uniforme.</p>
                <div class="dot">
graph G {
  layout=neato; overlap=false; splines=true;
  node [shape=circle style=filled fillcolor="#2b2b2b" fontcolor="#ffffff"];
  K0 -- K1; K0 -- K2; K0 -- K3; K1 -- K2; K1 -- K3; K2 -- K3;
}
                </div>
            </section>

            <section>
                <h3>Estrella (Star)</h3>
                <p>Un centro conectado a todos los demás; las hojas no están entre sí.</p>
                <div class="mermaid">
                    graph LR;
                    C((center)) --- L1((leaf1))
                    C --- L2((leaf2))
                    C --- L3((leaf3))
                    C --- L4((leaf4))
                    C --- L5((leaf5))
                </div>
            </section>

            <!-- Alternativa DOT: Estrella (radial real) -->
            <section>
                <h3>Estrella (DOT)</h3>
                <p>Centro radial; layout=twopi.</p>
                <div class="dot">
graph G {
  layout=twopi; root=center;
  node [shape=circle style=filled fillcolor="#2b2b2b" fontcolor="#ffffff"];
  center -- leaf1; center -- leaf2; center -- leaf3; center -- leaf4; center -- leaf5;
}
                </div>
            </section>

            <section>
                <h3>Bipartito Completo K(3,3)</h3>
                <p>Dos grupos; cada nodo de un grupo se conecta con todos los del otro.</p>
                <div class="mermaid">
                    graph LR;
                    A1((a0)); A2((a1)); A3((a2)); B1((b0)); B2((b1)); B3((b2));
                    A1 --- B1; A1 --- B2; A1 --- B3;
                    A2 --- B1; A2 --- B2; A2 --- B3;
                    A3 --- B1; A3 --- B2; A3 --- B3;
                </div>
            </section>

            <!-- Alternativa DOT: Bipartito completo -->
            <section>
                <h3>Bipartito K(3,3) (DOT)</h3>
                <p>Niveles por conjunto; layout=dot (rango por capas).</p>
                <div class="dot">
graph G {
  layout=dot; rankdir=LR; nodesep=0.4; ranksep=0.8;
  node [shape=circle style=filled fillcolor="#2b2b2b" fontcolor="#ffffff"];
  {rank=same; A0; A1; A2}
  {rank=same; B0; B1; B2}
  A0 -- B0; A0 -- B1; A0 -- B2; A1 -- B0; A1 -- B1; A1 -- B2; A2 -- B0; A2 -- B1; A2 -- B2;
}
                </div>
            </section>

            <section>
                <h3>Camino (Path)</h3>
                <p>Nodos en línea: extremos con un vecino, internos con dos.</p>
                <div class="mermaid">
                    graph LR;
                    P0((p0)) --- P1((p1)) --- P2((p2)) --- P3((p3)) --- P4((p4)) --- P5((p5))
                </div>
            </section>

            <!-- Alternativa DOT: Camino -->
            <section>
                <h3>Camino (DOT)</h3>
                <p>Disposición lineal izquierda a derecha.</p>
                <div class="dot">
graph G {
  layout=dot; rankdir=LR;
  node [shape=circle style=filled fillcolor="#2b2b2b" fontcolor="#ffffff"];
  P0 -- P1 -- P2 -- P3 -- P4 -- P5;
}
                </div>
            </section>

            <section>
                <h3>Rueda (Wheel)</h3>
                <p>Un centro conectado a un ciclo externo; mezcla de estrella y ciclo.</p>
                <div class="mermaid">
                    graph LR;
                    Hub((hub)) --- R0((rim0))
                    Hub --- R1((rim1))
                    Hub --- R2((rim2))
                    Hub --- R3((rim3))
                    Hub --- R4((rim4))
                    Hub --- R5((rim5))
                    R0 --- R1 --- R2 --- R3 --- R4 --- R5 --- R0
                </div>
            </section>

            <!-- Alternativa DOT: Rueda -->
            <section>
                <h3>Rueda (DOT)</h3>
                <p>Ciclo exterior circular con radios al centro.</p>
                <div class="dot">
graph G {
  layout=circo;
  node [shape=circle style=filled fillcolor="#2b2b2b" fontcolor="#ffffff"];
  hub; r0; r1; r2; r3; r4; r5;
  r0 -- r1 -- r2 -- r3 -- r4 -- r5 -- r0;
  hub -- r0; hub -- r1; hub -- r2; hub -- r3; hub -- r4; hub -- r5;
}
                </div>
            </section>

            <section>
                <h3>Petersen</h3>
                <p>Grafo famoso: 10 nodos, simétrico; útil como contraejemplo.</p>
                <div class="mermaid">
                    graph LR;
                    o0((o0)) --- o1((o1)) --- o2((o2)) --- o3((o3)) --- o4((o4)) --- o0;
                    i0((i0)) --- i2((i2)) --- i4((i4)) --- i1((i1)) --- i3((i3)) --- i0;
                    o0 --- i0; o1 --- i1; o2 --- i2; o3 --- i3; o4 --- i4;
                </div>
            </section>

            <section>
                <h3>Grilla 3x3 (Grid)</h3>
                <p>Nodos en filas y columnas; estructura cuadriculada.</p>
                <div class="mermaid">
                    graph LR;
                    g0_0((g0_0)) --- g0_1((g0_1)) --- g0_2((g0_2));
                    g1_0((g1_0)) --- g1_1((g1_1)) --- g1_2((g1_2));
                    g2_0((g2_0)) --- g2_1((g2_1)) --- g2_2((g2_2));
                    g0_0 --- g1_0 --- g2_0; g0_1 --- g1_1 --- g2_1; g0_2 --- g1_2 --- g2_2;
                </div>
            </section>

            <!-- Alternativa DOT: Grilla 3x3 con posiciones -->
            <section>
                <h3>Grilla 3x3 (DOT)</h3>
                <p>Posiciones fijas como cuadrícula (neato + pos).</p>
                <div class="dot">
graph G {
  layout=neato; overlap=false; splines=false;
  node [shape=circle style=filled fillcolor="#2b2b2b" fontcolor="#ffffff"];
  g00 [pos="0,2!"]; g01 [pos="1,2!"]; g02 [pos="2,2!"];
  g10 [pos="0,1!"]; g11 [pos="1,1!"]; g12 [pos="2,1!"];
  g20 [pos="0,0!"]; g21 [pos="1,0!"]; g22 [pos="2,0!"];
  g00 -- g01 -- g02; g10 -- g11 -- g12; g20 -- g21 -- g22;
  g00 -- g10 -- g20; g01 -- g11 -- g21; g02 -- g12 -- g22;
}
                </div>
            </section>

            <section>
                <h3>Planar (Triangulación simple)</h3>
                <p>Ciclo externo con diagonales desde un vértice sin cruces.</p>
                <div class="mermaid">
                    graph LR;
                    pl0((pl0)) --- pl1((pl1)) --- pl2((pl2)) --- pl3((pl3)) --- pl4((pl4)) --- pl0;
                    pl0 --- pl2; pl0 --- pl3; pl0 --- pl4;
                </div>
            </section>

            <section>
                <h3>Árbol Binario (height=3)</h3>
                <p>Cada nodo interno tiene dos hijos; sin ciclos.</p>
                <div class="mermaid">
                    graph TD;
                    t0((t0)) --- t1((t1)); t0 --- t2((t2));
                    t1 --- t3((t3)); t1 --- t4((t4));
                    t2 --- t5((t5)); t2 --- t6((t6));
                    t3 --- t7((t7)); t3 --- t8((t8));
                    t4 --- t9((t9)); t4 --- t10((t10));
                    t5 --- t11((t11)); t5 --- t12((t12));
                    t6 --- t13((t13)); t6 --- t14((t14));
                </div>
            </section>

            <!-- Alternativa DOT: Árbol binario -->
            <section>
                <h3>Árbol Binario (DOT)</h3>
                <p>Layout jerárquico (dot) en niveles.</p>
                <div class="dot">
digraph G {
  layout=dot; rankdir=TB;
  node [shape=circle style=filled fillcolor="#2b2b2b" fontcolor="#ffffff"];
  t0 -> t1; t0 -> t2; t1 -> t3; t1 -> t4; t2 -> t5; t2 -> t6; t3 -> t7; t3 -> t8; t4 -> t9; t4 -> t10; t5 -> t11; t5 -> t12; t6 -> t13; t6 -> t14;
}
                </div>
            </section>

            <section>
                <h3>Hipercubo (dimension=3)</h3>
                <p>Nodos representan cadenas de bits; aristas cambian un bit.</p>
                <div class="mermaid">
                    graph LR;
                    h000((000)) --- h001((001)) --- h011((011)) --- h010((010)) --- h000;
                    h100((100)) --- h101((101)) --- h111((111)) --- h110((110)) --- h100;
                    h000 --- h100; h001 --- h101; h011 --- h111; h010 --- h110;
                </div>
            </section>

            <!-- Alternativa DOT: Hipercubo 3D (cubo+conexiones) -->
            <section>
                <h3>Hipercubo (DOT)</h3>
                <p>Dos cuadrados conectados (neato, simetría).</p>
                <div class="dot">
graph G {
  layout=neato; overlap=false; splines=true;
  node [shape=circle style=filled fillcolor="#2b2b2b" fontcolor="#ffffff"];
  "000" -- "001" -- "011" -- "010" -- "000";
  "100" -- "101" -- "111" -- "110" -- "100";
  "000" -- "100"; "001" -- "101"; "011" -- "111"; "010" -- "110";
}
                </div>
            </section>

            <section>
                <h3>Prisma (n=5)</h3>
                <p>Dos ciclos paralelos conectados por pares de vértices.</p>
                <div class="mermaid">
                    graph LR;
                    c1_0((c1_0)) --- c1_1((c1_1)) --- c1_2((c1_2)) --- c1_3((c1_3)) --- c1_4((c1_4)) --- c1_0;
                    c2_0((c2_0)) --- c2_1((c2_1)) --- c2_2((c2_2)) --- c2_3((c2_3)) --- c2_4((c2_4)) --- c2_0;
                    c1_0 --- c2_0; c1_1 --- c2_1; c1_2 --- c2_2; c1_3 --- c2_3; c1_4 --- c2_4;
                </div>
            </section>

            <!-- Alternativa DOT: Prisma -->
            <section>
                <h3>Prisma (DOT)</h3>
                <p>Dos ciclos en paralelo conectados verticalmente.</p>
                <div class="dot">
graph G {
  layout=neato; overlap=false;
  node [shape=circle style=filled fillcolor="#2b2b2b" fontcolor="#ffffff"];
  c10 -- c11 -- c12 -- c13 -- c14 -- c10;
  c20 -- c21 -- c22 -- c23 -- c24 -- c20;
  c10 -- c20; c11 -- c21; c12 -- c22; c13 -- c23; c14 -- c24;
}
                </div>
            </section>

            <section>
                <h3>Kneser KG(5,2)</h3>
                <p>Es isomorfo al grafo de Petersen (misma estructura con distinto etiquetado).</p>
                <p>Vértices: subconjuntos de tamaño 2; arista si son disjuntos.</p>
                <div class="mermaid">
                    graph LR;
                    o0((012)) --- o1((013)) --- o2((014)) --- o3((023)) --- o4((024)) --- o0;
                    i0((034)) --- i2((124)) --- i4((123)) --- i1((134)) --- i3((234)) --- i0;
                    o0 --- i0; o1 --- i1; o2 --- i2; o3 --- i3; o4 --- i4;
                </div>
            </section>

            <section>
                <h3>Escalera (Ladder)</h3>
                <p>Dos caminos paralelos unidos por "peldaños".</p>
                <div class="mermaid">
                    graph LR;
                    l1_0((l1_0)) --- l1_1((l1_1)) --- l1_2((l1_2)) --- l1_3((l1_3));
                    l2_0((l2_0)) --- l2_1((l2_1)) --- l2_2((l2_2)) --- l2_3((l2_3));
                    l1_0 --- l2_0; l1_1 --- l2_1; l1_2 --- l2_2; l1_3 --- l2_3;
                </div>
            </section>

            <!-- Alternativa DOT: Escalera -->
            <section>
                <h3>Escalera (DOT)</h3>
                <p>Dos líneas paralelas con conectores.</p>
                <div class="dot">
graph G {
  layout=dot; rankdir=LR; ranksep=0.6; nodesep=0.4;
  node [shape=circle style=filled fillcolor="#2b2b2b" fontcolor="#ffffff"];
  {rank=same; l10; l11; l12; l13}
  {rank=same; l20; l21; l22; l23}
  l10 -- l11 -- l12 -- l13;
  l20 -- l21 -- l22 -- l23;
  l10 -- l20; l11 -- l21; l12 -- l22; l13 -- l23;
}
                </div>
            </section>

            <section>
                <h3>Escalera Circular (Circular Ladder)</h3>
                <p>Versión cerrada de la escalera: ambos extremos unidos formando ciclos.</p>
                <div class="mermaid">
                    graph LR;
                    cl1_0((c1_0)) --- cl1_1((c1_1)) --- cl1_2((c1_2)) --- cl1_3((c1_3)) --- cl1_4((c1_4)) --- cl1_0;
                    cl2_0((c2_0)) --- cl2_1((c2_1)) --- cl2_2((c2_2)) --- cl2_3((c2_3)) --- cl2_4((c2_4)) --- cl2_0;
                    cl1_0 --- cl2_0; cl1_1 --- cl2_1; cl1_2 --- cl2_2; cl1_3 --- cl2_3; cl1_4 --- cl2_4;
                </div>
            </section>

            <!-- Alternativa DOT: Escalera circular -->
            <section>
                <h3>Escalera Circular (DOT)</h3>
                <p>Dos ciclos paralelos conectados (prisma).</p>
                <div class="dot">
graph G {
  layout=neato; overlap=false;
  node [shape=circle style=filled fillcolor="#2b2b2b" fontcolor="#ffffff"];
  cl10 -- cl11 -- cl12 -- cl13 -- cl14 -- cl10;
  cl20 -- cl21 -- cl22 -- cl23 -- cl24 -- cl20;
  cl10 -- cl20; cl11 -- cl21; cl12 -- cl22; cl13 -- cl23; cl14 -- cl24;
}
                </div>
            </section>

            <section>
                <h3>Friendship (n=3)</h3>
                <p>Varios triángulos que comparten un vértice central.</p>
                <div class="mermaid">
                    graph LR;
                    FC((center)) --- F0_1((f0_1)) --- F0_2((f0_2)) --- FC;
                    FC --- F1_1((f1_1)) --- F1_2((f1_2)) --- FC;
                    FC --- F2_1((f2_1)) --- F2_2((f2_2)) --- FC;
                </div>
            </section>

            <!-- Alternativa DOT: Friendship -->
            <section>
                <h3>Friendship (DOT)</h3>
                <p>Triángulos compartiendo un centro (radial).</p>
                <div class="dot">
graph G {
  layout=twopi; root=center;
  node [shape=circle style=filled fillcolor="#2b2b2b" fontcolor="#ffffff"];
  center -- f01; center -- f02; f01 -- f02;
  center -- f11; center -- f12; f11 -- f12;
  center -- f21; center -- f22; f21 -- f22;
}
                </div>
            </section>

            <section>
                <h3>Crown (n=5)</h3>
                <p>Grafo bipartito completo sin las parejas directas (se quita el matching perfecto).</p>
                <div class="mermaid">
                    graph LR;
                    crown_a0((a0)); crown_a1((a1)); crown_a2((a2)); crown_a3((a3)); crown_a4((a4));
                    crown_b0((b0)); crown_b1((b1)); crown_b2((b2)); crown_b3((b3)); crown_b4((b4));
                    crown_a0 --- crown_b1; crown_a0 --- crown_b2; crown_a0 --- crown_b3; crown_a0 --- crown_b4;
                    crown_a1 --- crown_b0; crown_a1 --- crown_b2; crown_a1 --- crown_b3; crown_a1 --- crown_b4;
                    crown_a2 --- crown_b0; crown_a2 --- crown_b1; crown_a2 --- crown_b3; crown_a2 --- crown_b4;
                    crown_a3 --- crown_b0; crown_a3 --- crown_b1; crown_a3 --- crown_b2; crown_a3 --- crown_b4;
                    crown_a4 --- crown_b0; crown_a4 --- crown_b1; crown_a4 --- crown_b2; crown_a4 --- crown_b3;
                </div>
            </section>

            <!-- Alternativa DOT: Crown -->
            <section>
                <h3>Crown (DOT)</h3>
                <p>Bipartito por niveles sin matching perfecto.</p>
                <div class="dot">
graph G {
  layout=dot; rankdir=LR; nodesep=0.4; ranksep=0.8;
  node [shape=circle style=filled fillcolor="#2b2b2b" fontcolor="#ffffff"];
  {rank=same; a0; a1; a2; a3; a4}
  {rank=same; b0; b1; b2; b3; b4}
  a0 -- b1; a0 -- b2; a0 -- b3; a0 -- b4;
  a1 -- b0; a1 -- b2; a1 -- b3; a1 -- b4;
  a2 -- b0; a2 -- b1; a2 -- b3; a2 -- b4;
  a3 -- b0; a3 -- b1; a3 -- b2; a3 -- b4;
  a4 -- b0; a4 -- b1; a4 -- b2; a4 -- b3;
}
                </div>
            </section>

            <section>
                <h2>Conclusión</h2>
                <p>El problema de coloreo de grafos tiene importantes aplicaciones prácticas y es imprescindible elegir el algoritmo más adecuado para cada caso.</p>
            </section>

            <section>
                <h2>¿Preguntas?</h2>
            </section>

            <section>
                <h1>FIN</h1>
            </section>

        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.6.1/dist/reveal.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <!-- Graphviz (d3-graphviz) para representaciones más geométricas -->
    <script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@hpcc-js/wasm@2/dist/index.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-graphviz@5/build/d3-graphviz.min.js"></script>
    <script>
        Reveal.initialize({
            hash: true,
            slideNumber: true,
            transition: 'slide',
            backgroundTransition: 'slide',
            controls: true,
            progress: true,
            center: true,
            width: 1280,
            height: 720
        });

        // Configuración HPCC wasm para d3-graphviz
        if (window.hpccWasm && hpccWasm.wasmFolder) {
            hpccWasm.wasmFolder('https://cdn.jsdelivr.net/npm/@hpcc-js/wasm@2/dist/');
        }

        // Render diferido de Mermaid para evitar tamaños 0 al estar oculto
        mermaid.initialize({ startOnLoad: false });

        async function renderMermaidInSlide(slide) {
            const scope = slide || document.querySelector('.slides section.present');
            if (!scope) return;
            const blocks = scope.querySelectorAll('.mermaid:not([data-processed])');
            for (const el of blocks) {
                const code = el.textContent.trim();
                if (!code) continue;
                const id = 'mmd-' + Math.random().toString(36).slice(2);
                try {
                    const { svg } = await mermaid.render(id, code);
                    el.innerHTML = svg;
                    el.setAttribute('data-processed', 'true');
                } catch (err) {
                    console.error('Mermaid render error:', err);
                }
            }
        }

        function renderDotInSlide(slide) {
            const scope = slide || document.querySelector('.slides section.present');
            if (!scope) return;
            const blocks = scope.querySelectorAll('.dot:not([data-processed])');
            blocks.forEach(block => {
                const code = block.textContent.trim();
                if (!code) return;
                try {
                    // Limpiar el contenido de texto para que no se vea el DOT
                    block.innerHTML = '';
                    d3.select(block).graphviz({ useWorker: false }).renderDot(code);
                    block.setAttribute('data-processed', 'true');
                } catch (err) {
                    console.error('DOT render error:', err);
                }
            });
        }

        Reveal.on('ready', e => {renderMermaidInSlide(e.currentSlide); renderDotInSlide(e.currentSlide);});
        Reveal.on('slidechanged', e => {renderMermaidInSlide(e.currentSlide); renderDotInSlide(e.currentSlide);});
    </script>
</body>
</html>